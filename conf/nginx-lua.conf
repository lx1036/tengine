
# ./bin/sbin/nginx -c conf/nginx-lua.conf  -p .
# curl localhost:6080/lua
# hello world

worker_processes  1;
daemon off;
# master_process off;
# error_log  logs/error.log notice;
# pid        /var/run/nginx.pid;

# error_log logs/error.log debug;
error_log stderr notice;

events {
    worker_connections  255;
    # worker_connections  1024;
}



http {
    # include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for" "$proxy_protocol_addr" "$proxy_protocol_port"'
                      '$proxy_host $proxy_port $proxy_add_x_forwarded_for $proxy_internal_body_length $proxy_internal_chunked';

    # access_log  logs/access.log  main;
    access_log /dev/stderr main; 

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    # 这里需要加上 openresty 路径，否则报错 "module 'resty.core' not found"
    lua_package_path "/usr/local/Cellar/openresty/1.21.4.2_1/lualib/?.lua;;";
    lua_package_cpath "/usr/local/Cellar/openresty/1.21.4.2_1/lualib/?.so;;";


    # 测试 proxy-pass module
    server {
        listen 6080;
        root html;
        index index.html;
        # server_name server_names;
        # access_log  ${logs/server.access.log} main;
        # location / {
        # # location /proxy-pass {
        #     proxy_pass http://localhost:9091;
        #     proxy_set_header Host $host;
        #     proxy_set_header X-RealIP $remote_addr;
        # }

        # curl localhost:6080/lua
        location /lua {
            # set_by_lua_block $a {
            #     ngx.log(ngx.ERR, "set_by_lua*")
            # }

            # https://moonbingbing.gitbooks.io/openresty-best-practices/content/ngx_lua/phase.html
            rewrite_by_lua_block {
                ngx.log(ngx.INFO, "rewrite_by_lua*")
            }
            access_by_lua_block {
                ngx.log(ngx.INFO, "access_by_lua*")
            }
            content_by_lua_block {
                ngx.say("hello world")
            }
            header_filter_by_lua_block {
                ngx.log(ngx.INFO, "header_filter_by_lua*")
            }
            body_filter_by_lua_block {
                ngx.log(ngx.INFO, "body_filter_by_lua*")
            }
            log_by_lua_block {
                ngx.log(ngx.INFO, "log_by_lua*")
            }
        }
    }

    # 本地调试 dynamic-upstream
    # 管控端 server
    # 测试：
    # 增加一个 dyhost upstream: `curl -d "server 127.0.0.1:8089;server 127.0.0.1:8088;" 127.0.0.1:65502/upstream/dyhost`
    # curl 127.0.0.1:65502/list
    # curl 127.0.0.1:65502/detail
    # 访问 dyhost upstream: `curl -H "Host: dyhost" 127.0.0.1:65503`
    # "message from server 8088"
    # "message from server 8089"
    # 删除 dyhost upstream: `curl -i -X DELETE 127.0.0.1:65502/upstream/dyhost`
    server {
        listen 65502;
        access_log off;
        location / {
            dyups_interface;
        }
    }
    server {
        listen 65503;
        location / {
            proxy_pass http://$host;
        }
    }
    server {
        listen 8088;
        location / {
            content_by_lua_block {
                ngx.say("message from server 8088")
            }
        }
    }
    server {
        listen 8089;
        location / {
            content_by_lua_block {
                ngx.say("message from server 8089")
            }
        }
    }
}

stream {
    log_format  main '$binary_remote_addr $bytes_received $bytes_sent $connection'
    # access_log  logs/access.log  main;
    access_log /dev/stderr main; 

    # 这里需要加上 openresty 路径，否则报错 "module 'resty.core' not found"
    lua_package_path "/usr/local/Cellar/openresty/1.21.4.2_1/lualib/?.lua;;";
    lua_package_cpath "/usr/local/Cellar/openresty/1.21.4.2_1/lualib/?.so;;";

    server {
        listen 4001 reuseport;
        proxy_connect_timeout 1s;
        proxy_timeout 3s;
        proxy_pass tcp_backend;

        # https://github.com/openresty/stream-lua-nginx-module
        # content_by_lua_block 会拦截 proxy_pass 使得其无效，返回 "hello world from lua block"
        content_by_lua_block {
            ngx.say("hello world from lua block") -- output data
        }
        log_by_lua_block {
            ngx.log(ngx.INFO, "log_by_lua*")
        }
    }

    upstream tcp_backend {
        hash $remote_addr consistent;
        server 127.0.0.1:4000 max_fails=3 fail_timeout=30s weight=5;
    }

    server {
        # 这里 udp 居然不起作用!!! 报错 "API disabled in the current context"
        # 应该是配置错误!!!
        listen 2346 udp reuseport;

        # https://github.com/openresty/stream-lua-nginx-module
        content_by_lua_block {
            local udpsock = ngx.socket.udp()
            local ok, err = udpsock:send("hello world from lua block")
            if not ok then
                ngx.say("failed to connect to the datagram unix domain socket: ", err)
                return
            end
            ngx.say("successfully connected to memcached!")
            udpsock:close()
            return
        }
        log_by_lua_block {
            ngx.log(ngx.INFO, "log_by_lua*")
        }
    }

    upstream udp_backend {
        server 127.0.0.1:5000;
    }

    server {
        listen 5001 udp;
        proxy_pass udp_backend;
        
        # 定义 UDP 数据包处理的 Lua 脚本
        # 这里的示例脚本简单地将接收到的数据包转发到后端服务器
        # 你可以根据实际需求编写自定义的处理逻辑
        # lua_socket_receive_buffer_size 4096;
        content_by_lua_block {
            local sock = ngx.socket.udp()

            local data, err = sock:receive()
            if not data then
                ngx.log(ngx.ERR, "Failed to receive UDP packet: ", err)
                return ngx.exit(ngx.ERROR)
            end

            local ok, err = sock:setpeername("udp_backend")
            if not ok then
                ngx.log(ngx.ERR, "Failed to set peer name: ", err)
                return ngx.exit(ngx.ERROR)
            end

            local bytes, err = sock:send(data)
            if not bytes then
                ngx.log(ngx.ERR, "Failed to send UDP packet: ", err)
                return ngx.exit(ngx.ERROR)
            end

            sock:close()
        }
    }
}